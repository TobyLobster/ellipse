OSWRCH = $ffee
OSBYTE = $fff4
OSWORD = $fff1

; for multiply routines...
counter                     = $70
multiplier                  = $71
multiplicand                = $75
product                     = $79
result_index                = $81
product_index               = $81
param1_index                = $82
multiplicand_index          = $82
multiplier_index            = $83

; for divide...
divisor                     = $70       ; $71 used for high byte
dividend                    = $72       ; $73 used for high byte
remainder                   = $74       ; $75 used for high byte
result                      = dividend  ; save memory by reusing divident to store the result
divisor_index               = $76       ; index into variables for dividend

; for sqrt...
number_low                  = $70               ; number to find square root of low byte
number_high                 = number_low + 1    ; number to find square root of high byte
rem_low                     = $72               ; remainder low byte
rem_high                    = rem_low + 1       ; remainder high byte
temp_low                    = $74               ; temp partial low byte
temp_high                   = temp_low + 1      ; temp partial high byte
root                        = $76               ; square root

quadrant                    = $85
dir                         = $86
screen_low                  = $87
screen_high                 = $88
regular_dir                 = $89
current_dir                 = $8a
unused8b                    = $8b
tempYHigh                   = $8c
offsetWithinCharacterRow    = $8d
variable                    = $8e
temp                        = $8f

* = $2000

; ***************************************************************************************
!macro macro_add16 .r, .a, .b {
    lda .a                              ;
    clc                                 ;
    adc .b                              ;
    sta .r                              ;
    lda .a + 1                          ;
    adc .b + 1                          ;
    sta .r + 1                          ;
}

!macro macro_add32 .r, .a, .b {
    lda .a                              ;
    clc                                 ;
    adc .b                              ;
    sta .r                              ;
    lda .a + 1                          ;
    adc .b + 1                          ;
    sta .r + 1                          ;
    lda .a + 2                          ;
    adc .b + 2                          ;
    sta .r + 2                          ;
    lda .a + 3                          ;
    adc .b + 3                          ;
    sta .r + 3                          ;
}

!macro macro_dec16 .r {
    lda .r                              ;
    bne +                               ;
    dec .r + 1                          ;
+
    dec .r                              ;
}

; ***************************************************************************************
!macro macro_subtract16 .r, .a, .b {
    lda .a                              ;
    sec                                 ;
    sbc .b                              ;
    sta .r                              ;
    lda .a + 1                          ;
    sbc .b + 1                          ;
    sta .r + 1                          ;
}

; ***************************************************************************************
!macro macro_subtract32 .r, .a, .b {
    lda .a                              ;
    sec                                 ;
    sbc .b                              ;
    sta .r                              ;
    lda .a + 1                          ;
    sbc .b + 1                          ;
    sta .r + 1                          ;
    lda .a + 2                          ;
    sbc .b + 2                          ;
    sta .r + 2                          ;
    lda .a + 3                          ;
    sbc .b + 3                          ;
    sta .r + 3                          ;
}

; ***************************************************************************************
!macro macro_double16 .r {
    asl .r                              ;
    rol .r+1                            ;
}

; ***************************************************************************************
!macro macro_double32 .r {
    asl .r                              ;
    rol .r+1                            ;
    rol .r+2                            ;
    rol .r+3                            ;
}
; ***************************************************************************************
!macro macro_halve16 .r {
    lsr .r+1                            ;
    ror .r                              ;
}

; ***************************************************************************************
!macro macro_halve16 .r, .a {
    lda .a+1                            ;
    lsr                                 ;
    sta .r+1                            ;
    lda .a                              ;
    ror                                 ;
    sta .r                              ;
}

; ***************************************************************************************
!macro macro_halve32 .r {
    lsr .r+3                            ;
    ror .r+2                            ;
    ror .r+1                            ;
    ror .r                              ;
}

; ***************************************************************************************
!macro macro_copy16 .r, .a {
    lda .a                              ;
    sta .r                              ;
    lda .a+1                            ;
    sta .r+1                            ;
}

; ***************************************************************************************
!macro macro_copy32 .r, .a {
    lda .a                              ;
    sta .r                              ;
    lda .a+1                            ;
    sta .r+1                            ;
    lda .a+2                            ;
    sta .r+2                            ;
    lda .a+3                            ;
    sta .r+3                            ;
}

; ***************************************************************************************
!macro macro_zero16 .r {
    lda #0                              ;
    sta .r                              ;
    sta .r+1                            ;
}

; ***************************************************************************************
main
    jsr set_mode                        ;
    jsr reset_timer                     ;
    jmp interactive                     ;

draw_ellipse
    lda #0                              ;
    sta state                           ;
    sta state + 1                       ; reset state of each quadrant
    sta state + 2                       ;
    sta state + 3                       ;

    lda #a - variables_start            ;
    ldx #a - variables_start            ;
    ldy #aa - variables_start           ;
    jsr multiply16                      ; AA = A*A

    lda #b - variables_start            ;
    ldx #b - variables_start            ;
    ldy #bb - variables_start           ;
    jsr multiply16                      ; BB = B*B

    lda #bb - variables_start           ;
    ldx #eight - variables_start        ;
    ldy #bb_scaled - variables_start    ;
    jsr multiply16                      ; BBdouble = BB*8

    lda #a - variables_start            ;
    ldx #bb - variables_start           ;
    ldy #abb - variables_start          ;
    jsr multiply16                      ; ABB = A*BB

    lda #aa - variables_start           ;
    ldx #eight - variables_start        ;
    ldy #aa_scaled - variables_start    ;
    jsr multiply16                      ; AAdouble = AA*8

    lda #aa_scaled - variables_start    ;
    ldx #b - variables_start            ;
    ldy #aab_scaled - variables_start   ;
    jsr multiply32                      ; aab_scaled = AAdouble*B

    lda a
    sta xwidth                          ; xwidth = A ("X Width" is horizontal half-width of ellipse)

    lda #a - variables_start            ;
    ldx #b - variables_start            ;
    ldy #t2 - variables_start           ;
    jsr multiply16                      ; T2 = A*B

    +macro_double32 t2                  ; T2 = 2*T2
    +macro_add32 t2, t2, b              ; T2 = T2 + B
    +macro_add32 dr, abb, abb           ; DR = ABB + ABB
    +macro_double32 dr                  ; DR = 2*DR
    +macro_add32 dr, dr, bb             ; DR = DR + BB

    lda #b - variables_start            ;
    ldx #t2 - variables_start           ;
    ldy #fr - variables_start           ;
    jsr multiply32                      ; FR = B * T2

    +macro_subtract32 fr, fr, bb        ; FR = FR - BB
    +macro_double32 fr                  ; FR = 2*FR
    +macro_double32 fr                  ; FR = 2*FR

    +macro_copy32 ddr, aa               ; DDR = AA
    +macro_double32 ddr                 ; DDR = 2*DDR
    +macro_double32 ddr                 ; DDR = 2*DDR

setup_loop
    lda fr+3                            ;
    ora fr+2                            ;
    bne in_setup_loop                   ;

    lda ddr+3                           ;
    ora ddr+2                           ;
    bne in_setup_loop                   ;

    lda aab_scaled+3                    ;
    ora aab_scaled+2                    ;
    bne in_setup_loop                   ;

    lda fr+1                            ;
    ora ddr+1                           ;
    ora aab_scaled+1                    ;
    bpl done_setup_loop                 ; IF top bit of fr and DDR and aab_scaled is clear, branch

in_setup_loop
    +macro_halve32 bb_scaled            ; BBdouble /= 2
    +macro_halve32 aa_scaled            ; AAdouble /= 2
    +macro_halve32 dr                   ; DR /= 2
    +macro_halve32 fr                   ; FR /= 2
    +macro_halve32 ddr                  ; DDR /= 2   reduce everything down to 16 bits (losing some accuracy!)
    +macro_halve32 aab_scaled           ; AAB_scaled /= 2
    jmp setup_loop                      ;

done_setup_loop
    +macro_halve16 ec, b                ; EC = B / 2
    +macro_zero16 xc                    ; XC = 0

    +macro_copy16 oxr, a                ; OXR = A

    ldx #a - variables_start            ;
    ldy #oxl - variables_start          ;
    jsr negate16                        ; OXL = -A

    lda #0                              ;
    ldx #y - variables_start            ;
    jsr set_variable16_to_a             ; Y = 0

fory_loop

loop1
    ldx #dr - variables_start           ;
    ldy #fr - variables_start           ;
    jsr compare16                       ; increment=SGN(DR-FR)
    bmi done_loop1                      ; IF DR < FR THEN GOTO...
    beq done_loop1                      ; IF DR = FR THEN GOTO...

    lda xwidth+1                        ;
    bmi done_loop1                      ;

in_loop
    dec xwidth                          ; XW -= 1
    +macro_subtract16 dr, dr, fr        ; DR = DR - FR
    +macro_subtract16 fr, fr, bb_scaled ; FR = FR - BBdouble
    JMP loop1                           ;

done_loop1

    ; MOVE and DRAW right side
    +macro_add16 xr, xc, xwidth         ; XR = XC+XW

    ldx #xr - variables_start           ;
    ldy #oxr - variables_start          ;
    jsr compare16                       ; increment=SGN(XR-OXR)

    lda increment                       ; direction
    clc                                 ;
    adc #4                              ;
    sta regular_dir                     ;
    clc                                 ;
    adc #3                              ;
    sta current_dir                     ;

line_loop1
    +macro_add16 oxr, oxr, increment    ;

    lda current_dir                     ; direction
    ldx #1                              ; X is the quadrant to use
    ldy #oxr - variables_start          ; Y is the x coordinate to use
    jsr add_point                       ;

    lda regular_dir                     ;
    sta current_dir                     ;

    lda oxr                             ;
    cmp xr                              ;
    bne line_loop1                      ;

    ; MOVE and DRAW left side
    +macro_subtract16 xl, xc, xwidth    ; XL = XC-XW

    ldx #xl - variables_start           ;
    ldy #oxl - variables_start          ;
    jsr compare16                       ; increment=SGN(XL-OXL)

    lda increment                       ; direction
    clc                                 ;
    adc #4                              ;
    sta regular_dir                     ;
    clc                                 ;
    adc #3                              ;
    sta current_dir                     ;

line_loop2
    +macro_add16 oxl, oxl, increment    ;

    lda current_dir                     ; direction
    ldx #0                              ; X is the quadrant to use
    ldy #oxl - variables_start          ; Y is the x coordinate to use
    jsr add_point                       ;

    lda regular_dir                     ;
    sta current_dir                     ;

    lda oxl                             ;
    cmp xl                              ;
    bne line_loop2                      ; IF OXL != OL THEN GOTO...

    lda s+1                             ;
    bmi subtract_s                      ; IF S<0 GOTO...
    ora s                               ;
    beq store_increment                 ; IF S=0 GOTO...
add_s
    +macro_add16 ec, ec, s              ;
    lda #1                              ;
store_increment
    sta increment_s                     ;
    lda #0                              ;
    sta increment_s+1                   ;
    beq centre_line_loop                ; ALWAYS branch
subtract_s
    +macro_subtract16 ec, ec, s         ;
    lda #$ff                            ;
    sta increment_s                     ;
    sta increment_s+1                   ;

centre_line_loop
    ldx #ec - variables_start           ;
    ldy #b - variables_start            ;
    jsr compare16                       ;
    bmi done_centre_line_loop           ;
    beq done_centre_line_loop           ; if SGN(EC-B) <= 0 THEN GOTO ...

    +macro_add16 xc, xc, increment_s    ; XC += SGN(S)
    +macro_subtract16 ec, ec, b         ; EC -= B
    jmp centre_line_loop                ;

done_centre_line_loop
    +macro_add16 dr, dr, ddr            ; DR += DDR
    +macro_add16 ddr, ddr, aa_scaled    ; DDR += AAdouble

    inc y                               ;
    bne +                               ;
    inc y+1                             ; Y+=1
+

    lda y                               ;
    cmp b                               ;
    bne +                               ;
    lda y+1                             ;
    cmp b+1                             ;
    beq do_last_row                     ;
+
    jmp fory_loop                       ; IF B != Y GOTO fory_loop

do_last_row
    ; draw a horizontal line from left to right: XL+DX to XR-DX
    ldx #xr - variables_start           ;
    ldy #xl - variables_start           ;
    jsr compare16                       ; increment = SGN(XR-XL)

    +macro_subtract16 xr, xr, increment ; end point

    lda #4                              ;
    clc                                 ;
    adc increment                       ; A = 4 + increment        (i.e. the direction)
    sta temp                            ;

final_line_loop

    +macro_add16 xl, xl, increment      ;

    lda temp                            ;
    ldx #0                              ; X is the quadrant to use
    ldy #xl - variables_start           ; Y is the x coordinate to use
    jsr add_point                       ;

    lda xl                              ;
    cmp xr                              ;
    bne final_line_loop                 ;
    rts                                 ;


; ***************************************************************************************
;
; Y = A * X
;
; multiplies two 32 bit unsigned integers into a 32 bit result
;
; On Entry:
;   The registers are the byte offsets from variables_start to the variables:
;   A = multiplier      (4 bytes)
;   X = multiplicand    (4 bytes)
;   Y = result          (4 bytes)
;
; ***************************************************************************************
multiply32
    sta multiplier_index                ;
    stx multiplicand_index              ;
    sty product_index                   ;

    tax                                 ;
    ldy #multiplier                     ;
    jsr copy4_to_zp                     ;

    ldx multiplicand_index              ;
    ldy #multiplicand                   ;
    jsr copy4_to_zp                     ;

    lda #32                             ; set binary count to 32
    sta counter                         ;
    lda #0                              ;
    sta product + 4                     ; clear upper half of product
    sta product + 5                     ;
    sta product + 6                     ;
    sta product + 7                     ;
-
    lsr multiplier + 3                  ; shift multiplier right
    ror multiplier + 2                  ;
    ror multiplier + 1                  ;
    ror multiplier + 0                  ;
    bcc +                               ; go rotate right if c = 0

    lda product + 4                     ; get upper half of product and add multiplicand to it
    clc                                 ;
    adc multiplicand                    ;
    sta product + 4                     ;

    lda product + 5                     ;
    adc multiplicand + 1                ;
    sta product + 5                     ;

    lda product + 6                     ;
    adc multiplicand + 2                ;
    sta product + 6                     ;

    lda product + 7                     ;
    adc multiplicand + 3                ;

+
    ror                                 ; rotate partial product right
    sta product + 7                     ;
    ror product + 6                     ;
    ror product + 5                     ;
    ror product + 4                     ;
    ror product + 3                     ;
    ror product + 2                     ;
    ror product + 1                     ;
    ror product + 0                     ;
    dec counter                         ; decrement bit count and
    bne -                               ; loop until 32 bits are done

    ; copy result (4 bytes)
    ldx product_index                   ;
    ldy #3                              ;
-
    lda product,Y                       ;
    sta variables_start + 3,X           ;
    dex                                 ;
    dey                                 ;
    bpl -                               ;
    rts                                 ;

; ***************************************************************************************
copy4_to_zp
    lda variables_start,X               ;
    sta $00,Y                           ;
    lda variables_start + 1,X           ;
    sta $01,Y                           ;
    lda variables_start + 2,X           ;
    sta $02,Y                           ;
    lda variables_start + 3,X           ;
    sta $03,Y                           ;
    rts                                 ;

; ***************************************************************************************
copy2_to_zp
    lda variables_start,X               ;
    sta $00,Y                           ;
    lda variables_start + 1,X           ;
    sta $01,Y                           ;
    rts                                 ;

; ***************************************************************************************
set_variable16_to_a
    sta variables_start,X               ;
    lda #0                              ;
    sta variables_start + 1,X           ;
    rts                                 ;

; ***************************************************************************************
set_variable32_to_a
    sta variables_start,X               ;
    lda #0                              ;
    sta variables_start + 1,X           ;
    sta variables_start + 2,X           ;
    sta variables_start + 3,X           ;
    rts                                 ;

; ***************************************************************************************
just_copy
    sta variables_start + 1,Y           ;
    lda variables_start,X               ;
    sta variables_start,Y               ;
    rts                                 ;

; ***************************************************************************************
abs16
    lda variables_start + 1,X           ;
    bpl just_copy                       ;
    ; fall through...

; ***************************************************************************************
;
; Y = -X
;
; ***************************************************************************************
negate16
    lda #0                              ;
    sec                                 ;
    sbc variables_start,X               ;
    sta variables_start,Y               ;
    lda #0                              ;
    sbc variables_start + 1,X           ;
    sta variables_start + 1,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = -X
;
; ***************************************************************************************
negate32
    lda #0                              ;
    sec                                 ;
    sbc variables_start,X               ;
    sta variables_start,Y               ;
    lda #0                              ;
    sbc variables_start + 1,X           ;
    sta variables_start + 1,Y           ;
    lda #0                              ;
    sbc variables_start + 2,X           ;
    sta variables_start + 2,Y           ;
    lda #0                              ;
    sbc variables_start + 3,X           ;
    sta variables_start + 3,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = X
;
; ***************************************************************************************
copy32
    lda variables_start + 3,X           ;
    sta variables_start + 3,Y           ;
    lda variables_start + 2,X           ;
    sta variables_start + 2,Y           ;
copy16
    lda variables_start + 1,X           ;
    sta variables_start + 1,Y           ;
    lda variables_start,X               ;
    sta variables_start,Y               ;
    rts                                 ;

; ***************************************************************************************
;
; Y = A-X
;
; ***************************************************************************************
subtract16
    sty result_index                    ;
    sta param1_index                    ;
    tay                                 ;

    lda variables_start,Y               ;
    sec                                 ;
    sbc variables_start,X               ;
    ldy result_index                    ;
    sta variables_start,Y               ;
    ldy param1_index                    ;
    lda variables_start + 1,Y           ;
    sbc variables_start + 1,X           ;
    ldy result_index                    ;
    sta variables_start + 1,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = A-X
;
; ***************************************************************************************
subtract32
    sty result_index                    ;
    sta param1_index                    ;
    tay                                 ;

    lda variables_start,Y               ;
    sec                                 ;
    sbc variables_start,X               ;
    ldy result_index                    ;
    sta variables_start,Y               ;

    ldy param1_index                    ;
    lda variables_start + 1,Y           ;
    sbc variables_start + 1,X           ;
    ldy result_index                    ;
    sta variables_start + 1,Y           ;

    ldy param1_index                    ;
    lda variables_start + 2,Y           ;
    sbc variables_start + 2,X           ;
    ldy result_index                    ;
    sta variables_start + 2,Y           ;

    ldy param1_index                    ;
    lda variables_start + 3,Y           ;
    sbc variables_start + 3,X           ;
    ldy result_index                    ;
    sta variables_start + 3,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = Y-X
;
; ***************************************************************************************
decrement32
    lda variables_start,Y               ;
    sec                                 ;
    sbc variables_start,X               ;
    sta variables_start,Y               ;
    lda variables_start + 1,Y           ;
    sbc variables_start + 1,X           ;
    sta variables_start + 1,Y           ;

    lda variables_start + 2,Y           ;
    sbc variables_start + 2,X           ;
    sta variables_start + 2,Y           ;

    lda variables_start + 3,Y           ;
    sbc variables_start + 3,X           ;
    sta variables_start + 3,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = A+X
;
; ***************************************************************************************
add32
    sty result_index                    ;
    sta param1_index                    ;
    tay                                 ;

    lda variables_start,Y               ;
    clc                                 ;
    adc variables_start,X               ;
    ldy result_index                    ;
    sta variables_start,Y               ;

    ldy param1_index                    ;
    lda variables_start + 1,Y           ;
    adc variables_start + 1,X           ;
    ldy result_index                    ;
    sta variables_start + 1,Y           ;

    ldy param1_index                    ;
    lda variables_start + 2,Y           ;
    adc variables_start + 2,X           ;
    ldy result_index                    ;
    sta variables_start + 2,Y           ;

    ldy param1_index                    ;
    lda variables_start + 3,Y           ;
    adc variables_start + 3,X           ;
    ldy result_index                    ;
    sta variables_start + 3,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = Y+X
;
; ***************************************************************************************
increment32
    lda variables_start,Y               ;
    clc                                 ;
    adc variables_start,X               ;
    sta variables_start,Y               ;

    lda variables_start + 1,Y           ;
    adc variables_start + 1,X           ;
    sta variables_start + 1,Y           ;

    lda variables_start + 2,Y           ;
    adc variables_start + 2,X           ;
    sta variables_start + 2,Y           ;

    lda variables_start + 3,Y           ;
    adc variables_start + 3,X           ;
    sta variables_start + 3,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = A+X
; preserves X
;
; ***************************************************************************************
add16
    sty result_index                    ;
    sta param1_index                    ;
    tay                                 ;

    lda variables_start,Y               ;
    clc                                 ;
    adc variables_start,X               ;
    ldy result_index                    ;
    sta variables_start,Y               ;

    ldy param1_index                    ;
    lda variables_start + 1,Y           ;
    adc variables_start + 1,X           ;
    ldy result_index                    ;
    sta variables_start + 1,Y           ;

    rts                                 ;

; ***************************************************************************************
sgn16
    lda variables_start + 1,X           ;
    bmi negative                        ;
    bne positive                        ;
    ora variables_start + 0,X           ;
    beq iszero                          ;
    ; fall through...

positive
    lda #1                              ;
    sta variables_start + 0,X           ;
    lda #0                              ;
    sta variables_start + 1,X           ;
    rts                                 ;

negative
    lda #255                            ;
    ; fall through...

iszero
    sta variables_start + 0,X           ;
    sta variables_start + 1,X           ;
    rts                                 ;

; ***************************************************************************************
compare16
    lda variables_start,X               ;
    sec                                 ;
    sbc variables_start,Y               ;
    sta temp                            ;
    lda variables_start + 1,X           ;
    sbc variables_start + 1,Y           ;
    bmi less                            ;
    bne greater                         ;
    lda temp                            ;
    bne greater                         ;
equal
    lda #0                              ;
store_and_exit
    sta increment                       ;
    sta increment+1                     ;
    rts                                 ;
greater
    lda #0                              ;
    sta increment+1                     ;
    lda #1                              ;
    sta increment                       ;
    rts                                 ;
less
    lda #$ff                            ;
    bne store_and_exit                  ; ALWAYS branch


; ***************************************************************************************
;
; Y = X/2
;
; ***************************************************************************************
div2_32
    lda variables_start + 3,X           ;
    lsr                                 ;
    sta variables_start + 3,Y           ;
    lda variables_start + 2,X           ;
    ror                                 ;
    sta variables_start + 2,Y           ;
div2_16
    lda variables_start + 1,X           ;
    ror                                 ;
    sta variables_start + 1,Y           ;
    lda variables_start + 0,X           ;
    ror                                 ;
    sta variables_start + 0,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = A * X
;
; multiplies two 16 bit unsigned integers into a 32 bit result
;
; On Entry:
;   The registers are the byte offsets from variables_start to the variables:
;   A = multiplier      (2 bytes)
;   X = multiplicand    (2 bytes)
;   Y = result          (4 bytes)
;
; ***************************************************************************************
multiply16
    sta multiplier_index                ;
    stx multiplicand_index              ;
    sty product_index                   ;

    tax
    ldy #multiplier                     ;
    jsr copy2_to_zp                     ;

    ldx multiplicand_index              ;
    ldy #multiplicand                   ;
    jsr copy2_to_zp                     ;

    lda #16                             ; set binary count to 32
    sta counter                         ;
    lda #0                              ;
    sta product + 2                     ; clear upper half of product
    sta product + 3                     ;
-
    lsr multiplier + 1                  ; shift multiplier right
    ror multiplier + 0                  ;
    bcc +                               ; go rotate right if c = 0

    lda product + 2                     ; get upper half of product and add multiplicand to it
    clc                                 ;
    adc multiplicand                    ;
    sta product + 2                     ;

    lda product + 3                     ;
    adc multiplicand + 1                ;

+
    ror                                 ; rotate partial product right
    sta product + 3                     ;
    ror product + 2                     ;
    ror product + 1                     ;
    ror product + 0                     ;
    dec counter                         ; decrement bit count and
    bne -                               ; loop until 16 bits are done

    ; copy result (4 bytes)
    ldx product_index                   ;
    ldy #3                              ;
-
    lda product,Y                       ;
    sta variables_start + 3,X           ;
    dex                                 ;
    dey                                 ;
    bpl -                               ;
    rts                                 ;

; ***************************************************************************************
;
; From https://codebase64.org/doku.php?id=base:16bit_division_16-bit_result
;
; Y = A / X
;
; divides two 16 bit unsigned integers into a 16 bit result
;
; On Entry:
;   The registers are the byte offsets from variables_start to the variables:
;   A = dividend        (2 bytes)
;   X = divisor         (2 bytes)
;   Y = result          (2 bytes)
;
; ***************************************************************************************
divide16
    stx divisor_index                   ;
    sty result_index                    ;

    tax                                 ;
    ldy #dividend                       ;
    jsr copy2_to_zp                     ;

    ldx divisor_index                   ;
    ldy #divisor                        ;
    jsr copy2_to_zp                     ;

    lda #0                              ; preset remainder to 0
    sta remainder                       ;
    sta remainder+1                     ;
    ldx #16                             ; repeat for each bit: ...

divloop
    asl dividend                        ; dividend lb & hb*2, msb -> Carry
    rol dividend+1                      ;
    rol remainder                       ; remainder lb & hb * 2 + msb from carry
    rol remainder+1                     ;
    lda remainder                       ;
    sec                                 ;
    sbc divisor                         ; substract divisor to see if it fits in
    tay                                 ; lb result -> Y, for we may need it later
    lda remainder+1                     ;
    sbc divisor+1                       ;
    bcc skip                            ; if carry=0 then divisor didn't fit in yet

    sta remainder+1                     ; else save substraction result as new remainder,
    sty remainder                       ;
    inc dividend                        ; and INCrement result cause divisor fit in 1 times

skip
    dex                                 ;
    bne divloop                         ;

    ldy result_index                    ;
    lda dividend                        ;
    sta variables_start,y               ;
    lda dividend + 1                    ;
    sta variables_start + 1,y           ;
    rts                                 ;


; ***************************************************************************************
;
; From https://codebase64.org/doku.php?id=base:fast_sqrt
;
; A = SQRT(variables[x])
;
; On Entry:
;   X is the index into the variables_start for the 16 bit number to root
;
; On Exit:
;   A is the square root of the input number (8 bits)
;
; ***************************************************************************************
sqrt16
    lda variables_start,x       ;
    sta number_low              ;
    lda variables_start + 1,x   ;
    sta number_high             ;
sqrt16a
    ldy #0                      ; root = 0
    ldx #7                      ; loop counter from 7 to 1
    clc                         ; clear carry, bit 16 of number
loop
    tya                         ;
    ora stab-1,x                ;
    sta temp_high               ; temp_high = root OR 2^X   OLD NOTE: (root asl 8) | (d asl 7)

    ; Compare number_high with temp_high
    lda number_high             ;
    bcs skip0                   ; if number >= 65536 then t <= number is always true
    cmp temp_high               ;
    bcc skip1                   ; t <= number
skip0
    sbc temp_high               ;
    sta number_high             ; number = number - t
    tya                         ;
    ora stab,x                  ;
    tay                         ; root = root or d
skip1
    asl number_low              ;
    rol number_high             ; number = number * 2 (with carry as bit 16)
    dex                         ;
    bne loop                    ;

    ; last iteration
    bcs skip2                   ;
    sty temp_high               ;
    lda number_low              ;
    cmp #$80                    ;
    lda number_high             ;
    sbc temp_high               ;
    bcc skip3                   ;
skip2
    iny                         ; root = root or d (d is 1 here)
skip3
    tya                         ; output in A
return1
    rts                         ;
stab
    !byte $01,$02,$04,$08,$10,$20,$40,$80

; ***************************************************************************************
;
; add_point
;
; On Entry:
;    A      = current direction ('dir')
;    X      = quadrant
;    Y      = X variable to add
;
; ***************************************************************************************
add_point
    sta dir                             ;
    stx quadrant                        ;
    sty variable                        ;

    lda centrex                         ;
    clc                                 ;
    adc variables_start,y               ;
    sta newx                            ; newx = centrex + variable[y]
    lda centrex+1                       ;
    adc variables_start+1,y             ;
    sta newx+1                          ;

    lda centrey                         ;
    clc                                 ;
    adc y                               ;
    sta newy                            ;
    lda centrey+1                       ; newy = centrey + y
    adc y+1                             ;
    sta newy + 1                        ;

    jsr add_point_quadrant              ;

    lda y                               ;
    ora y + 1                           ;
    beq return1                         ; IF (Y=0) return


    ldy variable                        ;
    lda centrex                         ;
    sec                                 ;
    sbc variables_start,y               ;
    sta newx                            ; newx = centrex - variable[y]
    lda centrex+1                       ;
    sbc variables_start+1,y             ;
    sta newx+1                          ;

    lda centrey                         ;
    sec                                 ;
    sbc y                               ;
    sta newy                            ;
    lda centrey+1                       ; newy = centrey - y
    sbc y+1                             ;
    sta newy + 1                        ;


    lda #3                              ;
    sec                                 ;
    sbc quadrant                        ;
    sta quadrant                        ; quadrant = 3-quadrant

    lda #8                              ;
    sec                                 ;
    sbc dir                             ;
    sta dir                             ; dir = 8-dir
    ; fall through...

; ***************************************************************************************
;
; On Entry:
;   quadrant is the quadrant of the ellipse to add to
;   dir is the direction since the last point of the quadrant
;   newx, newy are the 16 bit coordinates of the point to add
;   state[quadrant] is the state of the processing:
;       0   Calculate the address of the first point and draw it
;       1   Draw the next point relative to the last
;
; ***************************************************************************************
add_point_quadrant
    ldx quadrant                        ;
    lda state,x                         ;
    bne state_one                       ; if (state[quadrant] == 1) { goto state_one }
    ; fall through...

; ***************************************************************************************
;
; Handle state zero
;
; On Entry:
;   X = quadrant
;   newx, newy are the 16 bit coordinates of the point to add
;
; ***************************************************************************************
state_zero
    lda newy                            ;
    and #7                              ;
    sta offsetWithinCharacterRow        ;
    lda newy+1                          ;
    sta tempYHigh                       ; A/tempYHigh = newy

    lda newy                            ;
    lsr tempYHigh                       ;
    ror                                 ;
    lsr tempYHigh                       ;
    ror                                 ;
    lsr tempYHigh                       ;
    ror                                 ;

    clc                                 ;
    adc screen_to_write_to              ;
    sta screenAddrHigh,x                ;

    lda newx                            ;
    and #%11111000                      ; offset in bytes from the start of the row
    clc                                 ;
    adc offsetWithinCharacterRow        ;
    sta screenAddrLow,x                 ;
    sta screen_low                      ;
    lda newx+1                          ;
    adc screenAddrHigh,x                ;
    sta screenAddrHigh,x                ;
    sta screen_high                     ;

    lda newx                            ;
    and #%00000111                      ; set mask,x based on horizontal position AND 7
    tay                                 ;
    lda bitset,y                        ;
    sta mask,x                          ;

    lda newx+1                          ;
    ora newy+1                          ; clipping
    bne clipped0                        ;

    ldy #0                              ;
    lda (screen_low),y                  ;
    eor mask,x                          ; write pixel
    sta (screen_low),y                  ;

clipped0
    lda #1                              ;
    sta state,x                         ; state[quadrant] = 1;
    rts                                 ;

; ***************************************************************************************
;
; Handle state one
;
; On Entry:
;   X = quadrant
;   dir = direction
;   newx, newy are the 16 bit coordinates of the point to add
;
; ***************************************************************************************
state_one
    lda screenAddrLow,x                 ;
    sta screen_low                      ;
    lda screenAddrHigh,x                ;
    sta screen_high                     ; copy current address from main memory into zp cache

    ; Test dx
    ldy dir                             ;
    lda dx,y                            ;
    bmi move_left                       ;
    beq test_dy                         ;

move_right
    lsr mask,x                          ;
    bcc test_dy                         ;
    lda #128                            ;
    sta mask,x                          ;
    lda screen_low                      ;
    clc                                 ;
    adc #8                              ;
    sta screen_low                      ;
    bcc test_dy                         ; }
    inc screen_high                     ; } needed to keep address straight for clipping purposes

    ; Test dy
test_dy
    lda dy,y                            ;
    bmi move_up                         ;
    beq write_pixel                     ;
move_down
    inc screen_low                      ;
    lda screen_low                      ;
    and #%00000111                      ;
    bne write_pixel                     ; if not on row boundary, skip
    inc screen_high                     ; increment high byte on row boundary
    lda screen_low                      ;
    sec                                 ;
    sbc #8                              ;
    sta screen_low                      ;

write_pixel
    lda newx+1                          ;
    ora newy+1                          ; clipping
    bne clipped                         ;

    ldy #0                              ;
    lda (screen_low),y                  ;
    eor mask,x                          ; write pixel
    sta (screen_low),y                  ;

clipped
    lda screen_low                      ;
    sta screenAddrLow,x                 ;
    lda screen_high                     ; restore current address back into main memory from zp cache
    sta screenAddrHigh,x                ;
    rts                                 ;

move_left
    asl mask,x                          ;
    bcc test_dy                         ;
    lda #1                              ;
    sta mask,x                          ;
    lda screen_low                      ;
    sec                                 ;
    sbc #8                              ;
    sta screen_low                      ;
    bcs test_dy                         ; }
    dec screen_high                     ; } needed to keep address straight for clipping purposes
    jmp test_dy                         ;

move_up
    lda screen_low                      ;
    dec screen_low                      ;
    and #%00000111                      ;
    bne write_pixel                     ; if not on row boundary, skip
    lda screen_low                      ;
    clc                                 ;
    adc #8                              ;
    sta screen_low                      ;
    dec screen_high                     ;
    jmp write_pixel                     ;

; ***************************************************************************************
state
    !byte 0,0,0,0
screenAddrLow
    !byte 0,0,0,0
screenAddrHigh
    !byte 0,0,0,0
mask
    !byte 0,0,0,0

bitset
    !byte %10000000
    !byte %01000000
    !byte %00100000
    !byte %00010000
    !byte %00001000
    !byte %00000100
    !byte %00000010
    !byte %00000001

; ***************************************************************************************
variables_start

; inputs
centrex
    !word 128
centrey
    !word 128
a
    !word 58
b
    !word 100
zero
    !word 0         ; padding (always zero), used to make multiply32 work on b
s
    !le32 -20       ; note: 32 bit (TODO is 32 bits needed?)


; workspace variables
xl
    !word 0
xr
    !word 0
xwidth
    !word 0
oxl
    !word 0
oxr
    !word 0
y
    !word 0
aa
    !le32 0
bb
    !le32 0

abb
    !le32 0

bb_scaled
    !le32 0
aa_scaled
    !le32 0
aab_scaled
    !le32 0
t2
    !le32 0
dr
    !le32 0
ddr
    !le32 0
fr
    !le32 0
ec
    !word 0
xc
    !word 0
newx
    !word 0
newy
    !word 0
increment
    !word 0
increment_s
    !word 0
x
    !word 0

eight
    !word 8

; Friendly parameters
axis_a
    !le32 100
axis_b
    !le32 58
angle_c
    !byte 0

majaxis
    !le32 0
minaxis
    !le32 0
angle
    !byte 0

; temporaries
sinang = aa
cosang = bb
temp1  = abb
temp2  = bb_scaled

; ***************************************************************************************
; static data
; ***************************************************************************************
dx
    !byte -1, 0, 1, -1, 0, 1, -1, 0, 1
dy
    !byte -1,-1,-1,0,0,0,1,1,1

; ***************************************************************************************
set_mode
    ldx #0                                  ;
-
    lda set_mode_data,x                     ;
    jsr OSWRCH                              ;
    inx                                     ;
    cpx #set_mode_data_end - set_mode_data  ;
    bne -                                   ;
    rts                                     ;

set_mode_data
    !byte 22, 4             ; Switch to screen mode 4

    !byte 23, 0, 6, 32      ; Set 6845 register R6 = 32
    !byte 0, 0, 0           ;
    !byte 0, 0, 0           ; This is the "vertical displayed" register, and sets
                            ; the number of displayed character rows to 32.

    !byte 23, 0, 12, $0C    ; Set 6845 register R12 = $0C and R13 = $00
    !byte 0, 0, 0           ;
    !byte 0, 0, 0           ; This sets 6845 registers (R12 R13) = $0C00 to point
    !byte 23, 0, 13, $00    ; to the start of screen memory in terms of character
    !byte 0, 0, 0           ; rows. There are 8 pixel lines in each character row,
    !byte 0, 0, 0           ; so to get the actual address of the start of screen
                            ; memory, we multiply by 8:
                            ;
                            ;   $0C00 * 8 = $6000
                            ;
                            ; So this sets the start of screen memory to $6000

    !byte 23, 0, 1, 32      ; Set 6845 register R1 = 32
    !byte 0, 0, 0           ;
    !byte 0, 0, 0           ; This is the "horizontal displayed" register, which
                            ; defines the number of character blocks per horizontal
                            ; character row. For comparison, this value is 40 for
                            ; modes 4 and 5, but our custom screen is not as wide at
                            ; only 32 character blocks across

    !byte 23, 0, 2, 45      ; Set 6845 register R2 = 45
    !byte 0, 0, 0           ;
    !byte 0, 0, 0           ; This is the "horizontal sync position" register, which
                            ; defines the position of the horizontal sync pulse on
                            ; the horizontal line in terms of character widths from
                            ; the left-hand side of the screen. For comparison this
                            ; is 49 for modes 4 and 5, but needs to be adjusted for
                            ; our custom screen's width

    !byte 23, 0, 10, 32     ; Set 6845 register R10 = 32
    !byte 0, 0, 0           ;
    !byte 0, 0, 0           ; This is the "cursor start" register, so this sets the
                            ; cursor start line at 0, effectively disabling the
                            ; cursor

    !byte 31,0,7            ; move the text cursor home
set_mode_data_end

timer_block
    !byte 0,0,0,0,0         ; TIME value to set

reset_timer
    lda #2                  ;
    ldx #<timer_block       ;
    ldy #>timer_block       ;
    jmp OSWORD              ; set TIME


; ***************************************************************************************
; ***************************************************************************************
; ***************************************************************************************
interactive
    lda #255                    ;
    sta changed                 ;

check_redraw
    lda changed                 ;
    beq later                   ;
    lda #0                      ;
    sta changed                 ;

    ; swap screen to write to
    lda screen_to_write_to      ;
    eor #$20                    ;
    sta screen_to_write_to      ;

    jsr clear_screen            ;
    jsr calculate_parameters    ;
    jsr draw_ellipse            ;

    ; swap screen shown (sets screen start address)
    jsr set_screen_start_address    ;

later
    jsr check_keys              ;
    lda escape                  ;
    bpl check_redraw            ;
    rts                         ;

check_key
    lda #129                    ;
    ldy #$ff                    ;
    jsr OSBYTE                  ;
    cpy #$ff                    ;
    rts                         ;

z_pressed
    dec changed                 ;
    jsr dec_a                   ;
    jmp next_key1               ;

x_pressed
    dec changed                 ;
    jsr inc_a                   ;
    jmp next_key1               ;

a_pressed
    dec changed                 ;
    lda angle_c                 ;
    clc                         ;
    adc #4                      ;
    sta angle_c                 ;
    jmp next_key1               ;

s_pressed
    dec changed                 ;
    lda angle_c                 ;
    sec                         ;
    sbc #4                      ;
    sta angle_c                 ;
    jmp next_key1               ;

colon_pressed
    dec changed                 ;
    jsr inc_b                   ;
    jmp next_key2               ;

fslash_pressed
    dec changed                 ;
    jsr dec_b                   ;
    jmp next_key2               ;

escape_pressed
    dec escape                  ;
    rts                         ;

check_keys
    ldx #$9e                    ; Look for 'Z'
    jsr check_key               ;
    beq z_pressed               ;

    ldx #$bd                    ; Look for 'X'
    jsr check_key               ;
    beq x_pressed               ;

    ldx #$be                    ; Look for 'A'
    jsr check_key               ;
    beq a_pressed               ;

    ldx #$ae                    ; Look for 'S'
    jsr check_key               ;
    beq s_pressed               ;

next_key1
    ldx #$b7                    ; Look for ':'
    jsr check_key               ;
    beq colon_pressed           ;

    ldx #$97                    ; Look for '/'
    jsr check_key               ;
    beq fslash_pressed          ;

    ldx #$97                    ; Look for '/'
    jsr check_key               ;
    beq fslash_pressed          ;

next_key2
    ldx #$8f                    ; Look for 'ESCAPE'
    jsr check_key               ;
    beq escape_pressed          ;
    rts                         ;

dec_a
    lda axis_a                  ;
    sec                         ;
    sbc #4                      ;
    cmp #8                      ;
    bcs ++                      ;
+
    lda #8                      ;
++
    sta axis_a                  ;
    rts

inc_a
    lda axis_a                  ;
    clc                         ;
    adc #4                      ;
    bcc +                       ;
    lda #255                    ;
+
    sta axis_a                  ;
    rts                         ;

dec_b
    lda axis_b                  ;
    sec                         ;
    sbc #4                      ;
    cmp #8                      ;
    bcs ++                      ;
+
    lda #8                      ;
++
    sta axis_b                  ;
    rts                         ;

inc_b
    lda axis_b                  ;
    clc                         ;
    adc #4                      ;
    bcc +                       ;
    lda #255                    ;
+
    sta axis_b                  ;
    rts                         ;



clear_screen
    lda screen_to_write_to      ;
    cmp #$60                    ;
    bne fast_screen_clear40     ;

fast_screen_clear60
    lda #0                      ;
    tax                         ;
-
    sta $6000,x                 ;
    sta $6100,x                 ;
    sta $6200,x                 ;
    sta $6300,x                 ;
    sta $6400,x                 ;
    sta $6500,x                 ;
    sta $6600,x                 ;
    sta $6700,x                 ;
    sta $6800,x                 ;
    sta $6900,x                 ;
    sta $6a00,x                 ;
    sta $6b00,x                 ;
    sta $6c00,x                 ;
    sta $6d00,x                 ;
    sta $6e00,x                 ;
    sta $6f00,x                 ;
    sta $7000,x                 ;
    sta $7100,x                 ;
    sta $7200,x                 ;
    sta $7300,x                 ;
    sta $7400,x                 ;
    sta $7500,x                 ;
    sta $7600,x                 ;
    sta $7700,x                 ;
    sta $7800,x                 ;
    sta $7900,x                 ;
    sta $7a00,x                 ;
    sta $7b00,x                 ;
    sta $7c00,x                 ;
    sta $7d00,x                 ;
    sta $7e00,x                 ;
    sta $7f00,x                 ;
    inx                         ;
    bne -                       ;
    rts                         ;

fast_screen_clear40
    lda #0                      ;
    tax                         ;
-
    sta $4000,x                 ;
    sta $4100,x                 ;
    sta $4200,x                 ;
    sta $4300,x                 ;
    sta $4400,x                 ;
    sta $4500,x                 ;
    sta $4600,x                 ;
    sta $4700,x                 ;
    sta $4800,x                 ;
    sta $4900,x                 ;
    sta $4a00,x                 ;
    sta $4b00,x                 ;
    sta $4c00,x                 ;
    sta $4d00,x                 ;
    sta $4e00,x                 ;
    sta $4f00,x                 ;
    sta $5000,x                 ;
    sta $5100,x                 ;
    sta $5200,x                 ;
    sta $5300,x                 ;
    sta $5400,x                 ;
    sta $5500,x                 ;
    sta $5600,x                 ;
    sta $5700,x                 ;
    sta $5800,x                 ;
    sta $5900,x                 ;
    sta $5a00,x                 ;
    sta $5b00,x                 ;
    sta $5c00,x                 ;
    sta $5d00,x                 ;
    sta $5e00,x                 ;
    sta $5f00,x                 ;
    inx                         ;
    bne -                       ;
    rts                         ;

; ***************************************************************************************
set_screen_start_address
    lda #19                     ;
    jsr OSBYTE                  ; *FX 19

    ldy #12                     ; Y = CRTC register to write into (0-15)
    lda screen_to_write_to      ;
    lsr                         ;
    lsr                         ;
    lsr                         ; A = value to write
    sty $fe00                   ; Write register number
    sta $fe01                   ; Write new value into register
    rts                         ;

changed
    !byte 0
escape
    !byte 0
screen_to_write_to
    !byte $40

; ***************************************************************************************
;
; From http://forum.6502.org/viewtopic.php?p=5789#p5789
;
; SIN(A) COS(A) routines. a full circle is represented by $00 to
; $00 in 256 1.40625 degree steps. returned value is signed 15
; bit with X being the high byte and ranges over +/-0.99997

; ***************************************************************************************
;
; get ABS(COS(A)) in AX
;
; ***************************************************************************************
abs_cos_A
    clc                         ; clear carry for add
    adc #$40                    ; add 1/4 rotation
    ; fall through...

; ***************************************************************************************
;
; get ABS(SIN(A)) in AX
;
; ***************************************************************************************
abs_sin_A
    and #$7f                    ; make +ve
    cmp #$41                    ; compare with max+1
    bcc quadrant1               ; branch if less

    eor #$7f                    ; wrap $41 to $7f ..
    adc #0                      ; .. to $3f to $00

quadrant1
    tay                         ; copy to index
    lda sintab_high,y           ; get SIN/COS table value high byte
    ldx sintab_low,y            ; get SIN/COS table value low byte
    rts                         ;

; ***************************************************************************************
;
; SIN table. returns values between $0000 and $FFFF
;
; ***************************************************************************************
sintab_high
    !byte $00
    !byte $06
    !byte $0c
    !byte $12
    !byte $19
    !byte $1f
    !byte $25
    !byte $2b
    !byte $31
    !byte $38
    !byte $3e
    !byte $44
    !byte $4a
    !byte $50
    !byte $56
    !byte $5c
    !byte $61
    !byte $67
    !byte $6d
    !byte $73
    !byte $78
    !byte $7e
    !byte $83
    !byte $88
    !byte $8e
    !byte $93
    !byte $98
    !byte $9d
    !byte $a2
    !byte $a7
    !byte $ab
    !byte $b0
    !byte $b5
    !byte $b9
    !byte $bd
    !byte $c1
    !byte $c5
    !byte $c9
    !byte $cd
    !byte $d1
    !byte $d4
    !byte $d8
    !byte $db
    !byte $de
    !byte $e1
    !byte $e4
    !byte $e7
    !byte $ea
    !byte $ec
    !byte $ee
    !byte $f1
    !byte $f3
    !byte $f4
    !byte $f6
    !byte $f8
    !byte $f9
    !byte $fb
    !byte $fc
    !byte $fd
    !byte $fe
    !byte $fe
    !byte $ff
    !byte $ff
    !byte $ff
    !byte $ff

sintab_low
    !byte $00
    !byte $48
    !byte $8f
    !byte $d5
    !byte $17
    !byte $56
    !byte $8f
    !byte $c3
    !byte $f1
    !byte $16
    !byte $33
    !byte $47
    !byte $4f
    !byte $4d
    !byte $3e
    !byte $21
    !byte $f7
    !byte $bd
    !byte $73
    !byte $19
    !byte $ac
    !byte $2e
    !byte $9b
    !byte $f5
    !byte $39
    !byte $67
    !byte $7f
    !byte $7f
    !byte $66
    !byte $35
    !byte $ea
    !byte $85
    !byte $04
    !byte $67
    !byte $ae
    !byte $d7
    !byte $e3
    !byte $d0
    !byte $9e
    !byte $4c
    !byte $da
    !byte $47
    !byte $93
    !byte $bd
    !byte $c4
    !byte $a9
    !byte $6a
    !byte $08
    !byte $82
    !byte $d7
    !byte $08
    !byte $13
    !byte $f9
    !byte $b9
    !byte $52
    !byte $c6
    !byte $13
    !byte $3a
    !byte $39
    !byte $12
    !byte $c3
    !byte $4d
    !byte $b0
    !byte $eb
    !byte $ff

; ***************************************************************************************
;
; Calculate (a,b,s) parameters for the draw_ellipse routine
; We start with (majaxis, minmaxis, angle) and calculate using:
;
;    cosang = COS(angle)
;    sinang = SIN(angle)
;    b = SQR( (minaxis * cosang)^2 + (majaxis * sinang)^2 )
;    s = (majaxis * majaxis - minaxis * minaxis) * cosang * sinang/b
;    a = (majaxis * minaxis)/b
;
; ***************************************************************************************
calculate_parameters
    lda axis_a                          ;
    cmp axis_b                          ;
    lda axis_a + 1                      ;
    sbc axis_b + 1                      ; compare axis_a with axis_b
    bcs axis_a_is_bigger                ; if axis_a is larger, then branch

    lda axis_a                          ; axis_a is the minor axis
    sta minaxis                         ; axis_b is the major axis
    lda axis_a + 1                      ;
    sta minaxis+1                       ;
    lda axis_b                          ;
    sta majaxis                         ;
    lda axis_b + 1                      ;
    sta majaxis + 1                     ;
    lda angle_c                         ;
    clc                                 ; Rotate by 90 degrees since we swapped the minor and major axes
    adc #$40                            ;
    jmp +                               ;

axis_a_is_bigger
    lda axis_a                          ; axis_a is the major axis
    sta majaxis                         ; axis_b is the minor axis
    lda axis_a + 1                      ;
    sta majaxis+1                       ;
    lda axis_b                          ;
    sta minaxis                         ;
    lda axis_b + 1                      ;
    sta minaxis + 1                     ;
    lda angle_c                         ;
+
    sta angle                           ;
    jsr abs_cos_A                       ; }
    stx cosang                          ; } cosang = 65535*ABS(COS(angle))
    sta cosang + 1                      ; }

    lda angle                           ; }
    jsr abs_sin_A                       ; }
    stx sinang                          ; } sinang = 65535*ABS(SIN(angle))
    sta sinang + 1                      ; }

    lda #minaxis - variables_start      ;
    ldx #cosang - variables_start       ;
    ldy #temp1 - variables_start        ;
    jsr multiply16                      ; temp1 = minaxis * cosang

    ; because cosang is 65535 times larger than the cos() function should be,
    ; then temp1 (as a 32 bit quantity) is 65535 times as big as it should be
    ; by copying the top two bytes to the lower two bytes and ignoring the top two bytes
    ; we effectively divide by 65536 to normalise the result
    +macro_copy16 temp1, temp1 + 2

    lda #temp1 - variables_start        ;
    ldx #temp1 - variables_start        ;
    ldy #temp1 - variables_start        ;
    jsr multiply16                      ; temp1 = temp1^2

    lda #majaxis - variables_start      ;
    ldx #sinang - variables_start       ;
    ldy #temp2 - variables_start        ;
    jsr multiply16                      ; temp2 = majaxis * sinang

    ; because sinang is 65535 times larger than the sin() function should be,
    ; we use the same argument as above to normalise the result
    +macro_copy16 temp2, temp2 + 2

    lda #temp2 - variables_start        ;
    ldx #temp2 - variables_start        ;
    ldy #temp2 - variables_start        ;
    jsr multiply16                      ; temp2 = temp2^2

    +macro_add16 temp1, temp1, temp2    ; temp1 += temp2

    ldx #temp1 - variables_start        ;
    jsr sqrt16                          ;
    sta b                               ; b = SQRT(temp1)

    lda #majaxis - variables_start      ;
    ldx #majaxis - variables_start      ;
    ldy #temp1 - variables_start        ;
    jsr multiply16                      ; temp1 = majaxis^2

    lda #minaxis - variables_start      ;
    ldx #minaxis - variables_start      ;
    ldy #temp2 - variables_start        ;
    jsr multiply16                      ; temp2 = minaxis^2

    +macro_subtract16 temp1, temp1, temp2    ; temp1 -= temp2

    lda #temp1 - variables_start        ;
    ldx #cosang - variables_start       ;
    ldy #temp1 - variables_start        ;
    jsr multiply16                      ; temp1 *= cosang
    +macro_copy16 temp1, temp1 + 2      ; scale down

    lda #temp1 - variables_start        ;
    ldx #sinang - variables_start       ;
    ldy #temp1 - variables_start        ;
    jsr multiply16                      ; temp1 *= sinang
    +macro_copy16 temp1, temp1 + 2      ; scale down

    lda #temp1 - variables_start        ;
    ldx #b - variables_start            ;
    ldy #s - variables_start            ;
    jsr divide16                        ; s = temp1 / b

    lda #0                              ;
    bit angle                           ;
    bvc +                               ; adjust for the sign required
    ldx #s - variables_start            ;
    ldy #s - variables_start            ;
    jsr negate16                        ; S = -S
    lda #255                            ; extend the sign
+
    sta s + 2                           ;
    sta s + 3                           ;

    lda #majaxis - variables_start      ;
    ldx #minaxis - variables_start      ;
    ldy #temp1 - variables_start        ;
    jsr multiply16                      ; temp1 = maj_axis * minaxis

    lda #temp1 - variables_start        ;
    ldx #b - variables_start            ;
    ldy #a - variables_start            ;
    jsr divide16                        ; a = temp1 / b

    rts                                 ;
