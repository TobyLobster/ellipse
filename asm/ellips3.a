OSWRCH = $FFEE
OSWORD = $fff1

counter      = $70
multiplier   = $71
multiplicand = $75
product      = $79

result_index        = $81
product_index       = $81
param1_index        = $82
multiplicand_index  = $82
multiplier_index    = $83

quadrant            = $85
dir                 = $86
screen_low          = $87
screen_high         = $88
tempX               = $89
tempY1              = $8a
tempY2              = $8b

* = $2400

; ***************************************************************************************
main
    jsr set_mode                        ;
    jsr reset_timer                     ;

draw_ellipse
    lda #a - variables_start            ;
    ldx #a - variables_start            ;
    ldy #aa - variables_start           ;
    jsr multiply16                      ; AA = A*A

    lda #b - variables_start            ;
    ldx #b - variables_start            ;
    ldy #bb - variables_start           ;
    jsr multiply16                      ; BB = B*B

    lda #0                              ;
    ldx #yyaa - variables_start         ;
    jsr set_variable32_to_a             ; YYAA = 0

    lda #aa - variables_start           ;
    ldx #bb - variables_start           ;
    ldy #aabb - variables_start         ;
    jsr multiply32                      ; AABB = AA*BB

    ldx #aa - variables_start           ;
    ldy #yyaa_diff - variables_start    ;
    jsr copy32                          ; YYAA_DIFF = AA

    lda #0                              ;
    sta state                           ;
    sta state + 1                       ; reset state of each quadrant
    sta state + 2                       ;
    sta state + 3                       ;

    ldx #a - variables_start            ;
    ldy #x1 - variables_start           ;
    jsr negate16                        ; X1 = -A

    lda #a - variables_start            ;
    ldx #b - variables_start            ;
    ldy #t2 - variables_start           ;
    jsr multiply16                      ; T2 = A*B

    ldx #t2 - variables_start           ;
    ldy #t1 - variables_start           ;
    jsr negate32                        ; T1 = -T2

    ldx #aabb - variables_start         ;
    ldy #tt1 - variables_start          ;
    jsr copy32                          ; TT1 = AABB

    lda #b - variables_start            ;
    ldx #t1 - variables_start           ;
    ldy #bt1 - variables_start          ;
    jsr multiply32                      ; BT1 = B*T1

    lda #s - variables_start            ;
    ldx #t1 - variables_start           ;
    ldy #st1 - variables_start          ;
    jsr multiply32                      ; ST1 = S*T1


    ldx #a - variables_start            ;
    ldy #x2 - variables_start           ;
    jsr copy16                          ; X2 = A

    ldx #aabb - variables_start         ;
    ldy #tt2 - variables_start          ;
    jsr copy32                          ; TT2=AABB

    ldx #bt1 - variables_start          ;
    ldy #bt2 - variables_start          ;
    jsr negate32                        ; BT2=-BT1

    ldx #st1 - variables_start          ;
    ldy #st2 - variables_start          ;
    jsr negate32                        ; ST2=-ST1

    ldx #bb - variables_start           ;
    ldy #bb2 - variables_start          ;
    jsr div2_32                         ; BB2 = BB/2

    lda #s - variables_start            ;
    ldx #b - variables_start            ;
    ldy #sb - variables_start           ;
    jsr multiply32                      ; SB = S*B

    lda #s - variables_start            ;
    ldx #s - variables_start            ;
    ldy #ss - variables_start           ;
    jsr multiply32                      ; SS = S*S

    lda #0                              ;
    ldx #y - variables_start            ;
    jsr set_variable16_to_a             ; Y = 0

fory_loop
    ; first add_point
    lda #x1 - variables_start           ;
    ldx #ox1 - variables_start          ;
    ldy #increment - variables_start    ;
    jsr subtract16                      ; increment=X1-OX1

    ldx #increment - variables_start    ;
    jsr sgn16                           ; increment=SGN(increment)

    lda increment                       ;
    clc                                 ;
    adc #7                              ; A = 7 + sgn(x1-ox1)      (i.e. the direction)
    ldx #0                              ; X is the quadrant to use
    ldy #x1 - variables_start           ; Y is the x coordinate to use
    jsr add_point                       ;


    ; second add_point
    lda #x2 - variables_start           ;
    ldx #ox2 - variables_start          ;
    ldy #increment - variables_start    ;
    jsr subtract16                      ; increment=X2-OX2

    ldx #increment - variables_start    ;
    jsr sgn16                           ; increment=SGN(increment)

    lda increment                       ;
    clc                                 ;
    adc #7                              ; A = 7 + sgn(x2-ox2)      (i.e. the direction)
    ldx #1                              ; X is the quadrant to use
    ldy #x2 - variables_start           ; Y is the x coordinate to use
    jsr add_point                       ;


    ldx #x1 - variables_start           ;
    ldy #ox1 - variables_start          ;
    jsr copy16                          ; OX1 = X1

    ldx #x2 - variables_start           ;
    ldy #ox2 - variables_start          ;
    jsr copy16                          ; OX2 = X2

    lda #aabb - variables_start         ;
    ldx #yyaa - variables_start         ;
    ldy #dd - variables_start           ; DD=AABB-YYAA
    jsr subtract32                      ;

    ; right half
repeat_loop1
    lda t2 + 3                          ;
    bpl +                               ;
    jmp inc_x2_t2                       ; IF T2<0 THEN GOTO ...
+
    ora t2 + 2                          ;
    ora t2 + 1                          ;
    ora t2 + 0                          ;
    beq post_loop1                      ; IF T2=0 THEN GOTO ...

    lda #tt2 - variables_start          ;
    ldx #dd - variables_start           ;
    ldy #d1 - variables_start           ;
    jsr subtract32                      ; D1=TT2-DD

    lda #bt2 - variables_start          ;
    ldx #bb2 - variables_start          ;
    ldy #bd - variables_start           ;
    jsr add32                           ; BD=BT2+BB2

    lda #bd - variables_start           ;
    ldx #d1 - variables_start           ;
    ldy #temp - variables_start         ;
    jsr subtract32                      ; temp = BD-D1

    lda temp+3                          ;
    bpl +                               ;
    jmp dec_x2_t2                       ; IF temp<0 THEN GOTO ...
+

    lda #bd - variables_start           ;
    ldx #d1 - variables_start           ;
    ldy #temp - variables_start         ;
    jsr add32                           ; temp = BD+D1

    lda temp+3                          ;
    bpl post_loop1                       ;
    jmp inc_x2_t2                       ; IF temp<0 THEN GOTO ...

post_loop1
    lda #x2 - variables_start           ;
    ldx #ox2 - variables_start          ;
    ldy #increment - variables_start    ;
    jsr subtract16                      ; increment=X2-OX2

    ldx #increment - variables_start    ;
    jsr sgn16                           ; increment=SGN(increment)

    lda #ox2 - variables_start          ;
    ldx #increment - variables_start    ;
    ldy #x - variables_start            ;
    jsr add16                           ; x = ox2 + increment

    ; loop to add points in a horizontal line
-
    lda x2                              ;
    cmp x                               ;
    bne +                               ;
    lda x2 + 1                          ;
    cmp x + 1                           ;
    beq done_first_half                 ; if (x == x2) then goto done1

+
    lda #4                              ;
    clc                                 ;
    adc increment                       ; A = 4 + increment       (i.e. the direction)
    ldx #1                              ; X is the quadrant to use
    ldy #x - variables_start            ; Y is the x coordinate to use
    jsr add_point                       ;

    lda #x - variables_start            ;
    ldx #increment - variables_start    ;
    ldy #x - variables_start            ;
    jsr add16                           ; x = x + increment

    jmp -                               ;

done_first_half

    ; left half
repeat_loop2
    lda t1 + 3                          ;
    bmi ++                              ;
    ora t1 + 2                          ;
    ora t1 + 1                          ;
    ora t1 + 0                          ;
    beq post_loop2                      ; IF T=0 THEN GOTO ...
    jmp dec_x1_t1                       ; IF T>0 THEN GOTO ...
++

    lda #tt1 - variables_start          ;
    ldx #dd - variables_start           ;
    ldy #d1 - variables_start           ;
    jsr subtract32                      ; D1=TT1-DD

    lda #bb2 - variables_start          ;
    ldx #bt1 - variables_start          ;
    ldy #bd - variables_start           ;
    jsr subtract32                      ; BD=BB2-BT1

    lda #bd - variables_start           ;
    ldx #d1 - variables_start           ;
    ldy #temp - variables_start         ;
    jsr subtract32                      ; temp = BD-D1

    lda temp+3                          ;
    bpl ++                              ;
    jmp inc_x1_t1                       ;
++

    lda #bd - variables_start           ;
    ldx #d1 - variables_start           ;
    ldy #temp - variables_start         ;
    jsr add32                           ; temp = BD+D1

    lda temp+3                          ;
    bpl post_loop2                      ;
    jmp dec_x1_t1                       ;

post_loop2
    lda #x1 - variables_start           ;
    ldx #ox1 - variables_start          ;
    ldy #increment - variables_start    ;
    jsr subtract16                      ; increment=X1-OX1

    ldx #increment - variables_start    ;
    jsr sgn16                           ; increment=SGN(increment)

    lda #ox1 - variables_start          ;
    ldx #increment - variables_start    ;
    ldy #x - variables_start            ;
    jsr add16                           ; x = ox1 + increment

    ; loop to add points in a horizontal line
-
    lda x1                              ;
    cmp x                               ;
    bne +                               ;
    lda x1 + 1                          ;
    cmp x + 1                           ;
    beq done_row                        ; if (x == x1) then goto done2

+
    lda #4                              ;
    clc                                 ;
    adc increment                       ; A = 4 + increment       (i.e. the direction)
    ldx #0                              ; X is the quadrant to use
    ldy #x - variables_start            ; Y is the x coordinate to use
    jsr add_point                       ;

    lda #x - variables_start            ;
    ldx #increment - variables_start    ;
    ldy #x - variables_start            ;
    jsr add16                           ; x = x + increment

    jmp -                               ;

done_row
    ldx #st2 - variables_start          ;
    ldy #tt2 - variables_start          ;
    jsr decrement32                     ; TT2-=ST2

    ldx #st2 - variables_start          ;
    ldy #tt2 - variables_start          ;
    jsr decrement32                     ; TT2-=ST2    (again)

    ldx #ss - variables_start           ;
    ldy #tt2 - variables_start          ;
    jsr increment32                     ; TT2+=SS

    ldx #st1 - variables_start          ;
    ldy #tt1 - variables_start          ;
    jsr decrement32                     ; TT1-=ST1

    ldx #st1 - variables_start          ;
    ldy #tt1 - variables_start          ;
    jsr decrement32                     ; TT1-=ST1    (again)

    ldx #ss - variables_start           ;
    ldy #tt1 - variables_start          ;
    jsr increment32                     ; TT1+=SS

    ldx #ss - variables_start           ;
    ldy #st2 - variables_start          ;
    jsr decrement32                     ; ST2-=SS

    ldx #ss - variables_start           ;
    ldy #st1 - variables_start          ;
    jsr decrement32                     ; ST1-=SS

    ldx #yyaa_diff - variables_start    ;
    ldy #yyaa - variables_start         ;
    jsr increment32                     ; YYAA+=YYA_DIFF

    ldx #aa - variables_start           ;
    ldy #yyaa_diff - variables_start    ;
    jsr increment32                     ; YYAA_DIFF+=AA

    ldx #aa - variables_start           ;
    ldy #yyaa_diff - variables_start    ;
    jsr increment32                     ; YYAA_DIFF+=AA   (again)

    ldx #sb - variables_start           ;
    ldy #bt2 - variables_start          ;
    jsr decrement32                     ; BT2-=SB

    ldx #sb - variables_start           ;
    ldy #bt1 - variables_start          ;
    jsr decrement32                     ; BT1-=SB

    ldx #s - variables_start            ;
    ldy #t2 - variables_start           ;
    jsr decrement32                     ; T2-=S

    ldx #s - variables_start            ;
    ldy #t1 - variables_start           ;
    jsr decrement32                     ; T1-=S

    inc y                               ;
    bne +                               ;
    inc y+1                             ; Y+=1
+

    lda y                               ;
    cmp b                               ;
    bne +                               ;
    lda y+1                             ;
    cmp b+1                             ;
    beq do_last_row                     ;
+
    jmp fory_loop                       ; IF B != Y GOTO fory_loop

do_last_row
    ; draw horizontal line from (cx+x1, cy+b) to (cx+x2, cy+b)
    ;                       and (cx-x1, cy-b) to (cx-x2, cy-b)

    lda #0
    sta state                           ; set quadrant 0 to state zero
    sta state + 1                       ; set quadrant 1 to state zero
    sta state + 2                       ; set quadrant 2 to state zero
    sta state + 3                       ; set quadrant 3 to state zero

    lda #x2 - variables_start           ;
    ldx #x1 - variables_start           ;
    ldy #increment2 - variables_start   ;
    jsr subtract16                      ; increment2=X2-X1

    ldx #increment2 - variables_start   ;
    jsr sgn16                           ; increment2=SGN(increment2)

    lda #4                              ;
    clc                                 ;
    adc increment2                      ; A = 4 + increment2       (i.e. the direction)
    sta final_line_loop + 1             ;

final_line_loop
    lda #$ff                            ;
    ldx #0                              ; X is the quadrant to use
    ldy #x1 - variables_start           ; Y is the x coordinate to use
    jsr add_point                       ;

    lda x1                              ;
    cmp x2                              ;
    beq +                               ;

    lda #x1 - variables_start           ;
    ldx #increment2 - variables_start   ;
    ldy #x1 - variables_start           ;
    jsr add16                           ; x = x + increment2

    jmp final_line_loop                 ;

+
    rts                                 ;

; ***************************************************************************************
inc_x2_t2
    inc x2                              ;
    bne +                               ;
    inc x2 + 1                          ; X2+=1
+
    ldx #b - variables_start            ;
    ldy #t2 - variables_start           ;
    jsr increment32                     ; T2+=B

    ldx #bt2 - variables_start          ;
    ldy #tt2 - variables_start          ;
    jsr increment32                     ; TT2+=BT2

    ldx #bt2 - variables_start          ;
    ldy #tt2 - variables_start          ;
    jsr increment32                     ; TT2+=BT2 (again)

    ldx #bb - variables_start           ;
    ldy #tt2 - variables_start          ;
    jsr increment32                     ; TT2+=BB

    ldx #bb - variables_start           ;
    ldy #bt2 - variables_start          ;
    jsr increment32                     ; BT2+=BB

    ldx #sb - variables_start           ;
    ldy #st2 - variables_start          ;
    jsr increment32                     ; ST2+=SB

    jmp repeat_loop1                    ;

; ***************************************************************************************
dec_x2_t2
    lda x2                              ;
    bne +                               ;
    dec x2 + 1                          ; X2-=1
+
    dec x2                              ;

    ldx #b - variables_start            ;
    ldy #t2 - variables_start           ;
    jsr decrement32                     ; T2-=B

    ldx #bt2 - variables_start          ;
    ldy #tt2 - variables_start          ;
    jsr decrement32                     ; TT2-=BT2

    ldx #bt2 - variables_start          ;
    ldy #tt2 - variables_start          ;
    jsr decrement32                     ; TT2-=BT2 (again)

    ldx #bb - variables_start           ;
    ldy #tt2 - variables_start          ;
    jsr increment32                     ; TT2+=BB

    ldx #bb - variables_start           ;
    ldy #bt2 - variables_start          ;
    jsr decrement32                     ; BT2-=BB

    ldx #sb - variables_start           ;
    ldy #st2 - variables_start          ;
    jsr decrement32                     ; ST2-=SB

    jmp repeat_loop1                    ;

; ***************************************************************************************
inc_x1_t1
    inc x1                              ;
    bne +                               ;
    inc x1 + 1                          ; X1+=1
+
    ldx #b - variables_start            ;
    ldy #t1 - variables_start           ;
    jsr increment32                     ; T1+=B

    ldx #bt1 - variables_start          ;
    ldy #tt1 - variables_start          ;
    jsr increment32                     ; TT1+=BT1

    ldx #bt1 - variables_start          ;
    ldy #tt1 - variables_start          ;
    jsr increment32                     ; TT1+=BT1 (again)

    ldx #bb - variables_start           ;
    ldy #tt1 - variables_start          ;
    jsr increment32                     ; TT1+=BB

    ldx #bb - variables_start           ;
    ldy #bt1 - variables_start          ;
    jsr increment32                     ; BT1+=BB

    ldx #sb - variables_start           ;
    ldy #st1 - variables_start          ;
    jsr increment32                     ; ST1+=SB

    jmp repeat_loop2                    ;

; ***************************************************************************************
dec_x1_t1
    lda x1                              ;
    bne +                               ;
    dec x1 + 1                          ; X1-=1
+
    dec x1                              ;

    ldx #b - variables_start            ;
    ldy #t1 - variables_start           ; T1-=B
    jsr decrement32                     ;

    ldx #bt1 - variables_start          ;
    ldy #tt1 - variables_start          ;
    jsr decrement32                     ; TT1-=BT1

    ldx #bt1 - variables_start          ;
    ldy #tt1 - variables_start          ;
    jsr decrement32                     ; TT1-=BT1 (again)

    ldx #bb - variables_start           ;
    ldy #tt1 - variables_start          ;
    jsr increment32                     ; TT1+=BB

    ldx #bb - variables_start           ;
    ldy #bt1 - variables_start          ;
    jsr decrement32                     ; BT1-=BB

    ldx #sb - variables_start           ;
    ldy #st1 - variables_start          ;
    jsr decrement32                     ; ST1-=SB

    jmp repeat_loop2                    ;

; ***************************************************************************************
;
; Y = A * X
;
; multiplies two 32 bit unsigned integers into a 32 bit result
;
; On Entry:
;   The registers are the byte offsets from variables_start to the variables:
;   A = multiplier      (4 bytes)
;   X = multiplicand    (4 bytes)
;   Y = result          (4 bytes)
;
; ***************************************************************************************
multiply32
    sta multiplier_index                ;
    stx multiplicand_index              ;
    sty product_index                   ;

    tax
    ldy #multiplier                     ;
    jsr copy4_to_zp                     ;

    ldx multiplicand_index              ;
    ldy #multiplicand                   ;
    jsr copy4_to_zp                     ;

    lda #32                             ; set binary count to 32
    sta counter                         ;
    lda #0                              ;
    sta product + 4                     ; clear upper half of product
    sta product + 5                     ;
    sta product + 6                     ;
    sta product + 7                     ;
-
    lsr multiplier + 3                  ; shift multiplier right
    ror multiplier + 2                  ;
    ror multiplier + 1                  ;
    ror multiplier + 0                  ;
    bcc +                               ; go rotate right if c = 0

    lda product + 4                     ; get upper half of product and add multiplicand to it
    clc                                 ;
    adc multiplicand                    ;
    sta product + 4                     ;

    lda product + 5                     ;
    adc multiplicand + 1                ;
    sta product + 5                     ;

    lda product + 6                     ;
    adc multiplicand + 2                ;
    sta product + 6                     ;

    lda product + 7                     ;
    adc multiplicand + 3                ;

+
    ror                                 ; rotate partial product right
    sta product + 7                     ;
    ror product + 6                     ;
    ror product + 5                     ;
    ror product + 4                     ;
    ror product + 3                     ;
    ror product + 2                     ;
    ror product + 1                     ;
    ror product + 0                     ;
    dec counter                         ; decrement bit count and
    bne -                               ; loop until 32 bits are done

    ; copy result (4 bytes)
    ldx product_index                   ;
    ldy #3                              ;
-
    lda product,Y                       ;
    sta variables_start + 3,X           ;
    dex                                 ;
    dey                                 ;
    bpl -                               ;
    rts                                 ;

; ***************************************************************************************
plot_block
    !word 0                             ; NOTE: These bytes are reversed
    !word 0                             ; when sending to the VDU drivers
plot_type
    !byte 5                             ; PLOT type
    !byte 25                            ; VDU 25 for PLOT

; ***************************************************************************************
; PLOT plot_type, centreX + variables[X],centreY + variables[Y]
plot_xy
    lda variables_start,X               ;
    clc                                 ;
    adc centrex                         ;
    sta plot_block + 3                  ;
    lda variables_start + 1,X           ;
    adc centrex + 1                     ;
    sta plot_block + 2                  ;

    lda variables_start,Y               ;
    clc                                 ;
    adc centrey                         ;
    sta plot_block + 1                  ;
    lda variables_start + 1,Y           ;
    adc centrey + 1                     ;
    sta plot_block + 0                  ;

mult_by_four_and_plot
    asl plot_block + 1                  ;
    rol plot_block                      ;
    asl plot_block + 1                  ;
    rol plot_block                      ; multiply coordinates by four
    asl plot_block + 3                  ;
    rol plot_block + 2                  ;
    asl plot_block + 3                  ;
    rol plot_block + 2                  ;

    ldx #5                              ;
-
    lda plot_block,X                    ;
    jsr OSWRCH                          ;
    dex                                 ;
    bpl -                               ;
    rts                                 ;

; ***************************************************************************************
plot_point
    lda #69                             ; PLOT 69 (point)
    sta plot_type                       ;

    lda pixelx                          ;
    clc                                 ;
    adc centrex                         ;
    sta plot_block + 3                  ;

    lda pixelx + 1                      ;
    adc centrex + 1                     ;
    sta plot_block + 2                  ;

    lda pixely                          ;
    clc                                 ;
    adc centrey                         ;
    sta plot_block + 1                  ;

    lda pixely + 1                      ;
    adc centrey + 1                     ;
    sta plot_block + 0                  ;

    jmp mult_by_four_and_plot           ;

; ***************************************************************************************
copy4_to_zp
    lda variables_start,X               ;
    sta $00,Y                           ;
    lda variables_start + 1,X           ;
    sta $01,Y                           ;
    lda variables_start + 2,X           ;
    sta $02,Y                           ;
    lda variables_start + 3,X           ;
    sta $03,Y                           ;
    rts                                 ;

; ***************************************************************************************
copy2_to_zp
    lda variables_start,X               ;
    sta $00,Y                           ;
    lda variables_start + 1,X           ;
    sta $01,Y                           ;
    rts                                 ;

; ***************************************************************************************
set_variable16_to_a
    sta variables_start,X               ;
    lda #0                              ;
    sta variables_start + 1,X           ;
    rts                                 ;

; ***************************************************************************************
set_variable32_to_a
    sta variables_start,X               ;
    lda #0                              ;
    sta variables_start + 1,X           ;
    sta variables_start + 2,X           ;
    sta variables_start + 3,X           ;
    rts                                 ;

; ***************************************************************************************
just_copy
    sta variables_start + 1,Y           ;
    lda variables_start,X               ;
    sta variables_start,Y               ;
    rts                                 ;

; ***************************************************************************************
abs16
    lda variables_start + 1,X           ;
    bpl just_copy                       ;
    ; fall through...

; ***************************************************************************************
;
; Y = -X
;
; ***************************************************************************************
negate16
    lda #0                              ;
    sec                                 ;
    sbc variables_start,X               ;
    sta variables_start,Y               ;
    lda #0                              ;
    sbc variables_start + 1,X           ;
    sta variables_start + 1,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = -X
;
; ***************************************************************************************
negate32
    lda #0                              ;
    sec                                 ;
    sbc variables_start,X               ;
    sta variables_start,Y               ;
    lda #0                              ;
    sbc variables_start + 1,X           ;
    sta variables_start + 1,Y           ;
    lda #0                              ;
    sbc variables_start + 2,X           ;
    sta variables_start + 2,Y           ;
    lda #0                              ;
    sbc variables_start + 3,X           ;
    sta variables_start + 3,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = X
;
; ***************************************************************************************
copy32
    lda variables_start + 3,X           ;
    sta variables_start + 3,Y           ;
    lda variables_start + 2,X           ;
    sta variables_start + 2,Y           ;
copy16
    lda variables_start + 1,X           ;
    sta variables_start + 1,Y           ;
    lda variables_start,X               ;
    sta variables_start,Y               ;
    rts                                 ;

; ***************************************************************************************
;
; Y = A-X
;
; ***************************************************************************************
subtract16
    sty result_index                    ;
    sta param1_index                    ;
    tay                                 ;

    lda variables_start,Y               ;
    sec                                 ;
    sbc variables_start,X               ;
    ldy result_index                    ;
    sta variables_start,Y               ;
    ldy param1_index                    ;
    lda variables_start + 1,Y           ;
    sbc variables_start + 1,X           ;
    ldy result_index                    ;
    sta variables_start + 1,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = A-X
;
; ***************************************************************************************
subtract32
    sty result_index                    ;
    sta param1_index                    ;
    tay                                 ;

    lda variables_start,Y               ;
    sec                                 ;
    sbc variables_start,X               ;
    ldy result_index                    ;
    sta variables_start,Y               ;

    ldy param1_index                    ;
    lda variables_start + 1,Y           ;
    sbc variables_start + 1,X           ;
    ldy result_index                    ;
    sta variables_start + 1,Y           ;

    ldy param1_index                    ;
    lda variables_start + 2,Y           ;
    sbc variables_start + 2,X           ;
    ldy result_index                    ;
    sta variables_start + 2,Y           ;

    ldy param1_index                    ;
    lda variables_start + 3,Y           ;
    sbc variables_start + 3,X           ;
    ldy result_index                    ;
    sta variables_start + 3,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = Y-X
;
; ***************************************************************************************
decrement32
    lda variables_start,Y               ;
    sec                                 ;
    sbc variables_start,X               ;
    sta variables_start,Y               ;
    lda variables_start + 1,Y           ;
    sbc variables_start + 1,X           ;
    sta variables_start + 1,Y           ;

    lda variables_start + 2,Y           ;
    sbc variables_start + 2,X           ;
    sta variables_start + 2,Y           ;

    lda variables_start + 3,Y           ;
    sbc variables_start + 3,X           ;
    sta variables_start + 3,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = A+X
;
; ***************************************************************************************
add32
    sty result_index                    ;
    sta param1_index                    ;
    tay                                 ;

    lda variables_start,Y               ;
    clc                                 ;
    adc variables_start,X               ;
    ldy result_index                    ;
    sta variables_start,Y               ;

    ldy param1_index                    ;
    lda variables_start + 1,Y           ;
    adc variables_start + 1,X           ;
    ldy result_index                    ;
    sta variables_start + 1,Y           ;

    ldy param1_index                    ;
    lda variables_start + 2,Y           ;
    adc variables_start + 2,X           ;
    ldy result_index                    ;
    sta variables_start + 2,Y           ;

    ldy param1_index                    ;
    lda variables_start + 3,Y           ;
    adc variables_start + 3,X           ;
    ldy result_index                    ;
    sta variables_start + 3,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = Y+X
;
; ***************************************************************************************
increment32
    lda variables_start,Y               ;
    clc                                 ;
    adc variables_start,X               ;
    sta variables_start,Y               ;

    lda variables_start + 1,Y           ;
    adc variables_start + 1,X           ;
    sta variables_start + 1,Y           ;

    lda variables_start + 2,Y           ;
    adc variables_start + 2,X           ;
    sta variables_start + 2,Y           ;

    lda variables_start + 3,Y           ;
    adc variables_start + 3,X           ;
    sta variables_start + 3,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = A+X
; preserves X
;
; ***************************************************************************************
add16
    sty result_index                    ;
    sta param1_index                    ;
    tay                                 ;

    lda variables_start,Y               ;
    clc                                 ;
    adc variables_start,X               ;
    ldy result_index                    ;
    sta variables_start,Y               ;

    ldy param1_index                    ;
    lda variables_start + 1,Y           ;
    adc variables_start + 1,X           ;
    ldy result_index                    ;
    sta variables_start + 1,Y           ;

    rts                                 ;

; ***************************************************************************************
sgn16
    lda variables_start + 1,X           ;
    bmi negative                        ;
    bne positive                        ;
    ora variables_start + 0,X           ;
    beq iszero                          ;
    ; fall through...

positive
    lda #1                              ;
    sta variables_start + 0,X           ;
    lda #0                              ;
    sta variables_start + 1,X           ;
    rts                                 ;

negative
    lda #255                            ;
    ; fall through...

iszero
    sta variables_start + 0,X           ;
    sta variables_start + 1,X           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = X/2
;
; ***************************************************************************************
div2_32
    lda variables_start + 3,X           ;
    lsr                                 ;
    sta variables_start + 3,Y           ;
    lda variables_start + 2,X           ;
    ror                                 ;
    sta variables_start + 2,Y           ;
div2_16
    lda variables_start + 1,X           ;
    ror                                 ;
    sta variables_start + 1,Y           ;
    lda variables_start + 0,X           ;
    ror                                 ;
    sta variables_start + 0,Y           ;
    rts                                 ;

; ***************************************************************************************
;
; Y = A * X
;
; multiplies two 16 bit unsigned integers into a 32 bit result
;
; On Entry:
;   The registers are the byte offsets from variables_start to the variables:
;   A = multiplier      (2 bytes)
;   X = multiplicand    (2 bytes)
;   Y = result          (4 bytes)
;
; ***************************************************************************************
multiply16
    sta multiplier_index                ;
    stx multiplicand_index              ;
    sty product_index                   ;

    tax
    ldy #multiplier                     ;
    jsr copy2_to_zp                     ;

    ldx multiplicand_index              ;
    ldy #multiplicand                   ;
    jsr copy2_to_zp                     ;

    lda #16                             ; set binary count to 32
    sta counter                         ;
    lda #0                              ;
    sta product + 2                     ; clear upper half of product
    sta product + 3                     ;
-
    lsr multiplier + 1                  ; shift multiplier right
    ror multiplier + 0                  ;
    bcc +                               ; go rotate right if c = 0

    lda product + 2                     ; get upper half of product and add multiplicand to it
    clc                                 ;
    adc multiplicand                    ;
    sta product + 2                     ;

    lda product + 3                     ;
    adc multiplicand + 1                ;

+
    ror                                 ; rotate partial product right
    sta product + 3                     ;
    ror product + 2                     ;
    ror product + 1                     ;
    ror product + 0                     ;
    dec counter                         ; decrement bit count and
    bne -                               ; loop until 16 bits are done

    ; copy result (4 bytes)
    ldx product_index                   ;
    ldy #3                              ;
-
    lda product,Y                       ;
    sta variables_start + 3,X           ;
    dex                                 ;
    dey                                 ;
    bpl -                               ;
return1
    rts                                 ;

; ***************************************************************************************
;
; add_point
;
; On Entry:
;    A      = current direction ('dir')
;    X      = quadrant
;    Y      = X variable to add
;
; ***************************************************************************************
add_point
    sta dir                             ;
    stx quadrant                        ;

    lda variables_start,y               ;
    sta newx                            ; newx = variable[y]
    lda variables_start + 1,y           ;
    sta newx + 1                        ;

    lda y                               ;
    sta newy                            ;
    lda y+1                             ; newy = y
    sta newy + 1                        ;

    jsr add_point_quadrant              ;

    lda newy                            ;
    ora newy + 1                        ;
    beq return1                         ; IF (Y=0) return

    ldx #newy - variables_start         ;
    ldy #newy - variables_start         ;
    jsr negate16                        ; newy = -newy

    ldx #newx - variables_start         ;
    ldy #newx - variables_start         ;
    jsr negate16                        ; newx = -newx

    lda #3                              ;
    sec                                 ;
    sbc quadrant                        ;
    sta quadrant                        ; quadrant = 3-quadrant

    lda #8                              ;
    sec                                 ;
    sbc dir                             ;
    sta dir                             ; dir = 8-dir
    ; fall through...

; ***************************************************************************************
;
; On Entry:
;   quadrant is the quadrant of the ellipse to add to
;   dir is the direction since the last point of the quadrant
;   newx, newy are the 16 bit coordinates of the point to add
;   state[quadrant] is the state of the processing:
;       0   Calculate the address of the first point and draw it
;       1   Draw the next point relative to the last
;
; ***************************************************************************************
add_point_quadrant
    ; to test the right points are here draw a point and return
    ;lda #69                             ;
    ;sta plot_type                       ;
    ;ldx #newx - variables_start         ;
    ;ldy #newy - variables_start         ;
    ;jmp plot_xy                         ; PLOT 69, newx*4, newy*4

    ldx quadrant                        ;
    lda state,x                         ;
    bne state_one                       ; if (state[quadrant] == 0) { goto state_zero }
    ; fall through...

; ***************************************************************************************
;
; Handle state zero
;
; On Entry:
;   X = quadrant
;   newx, newy are the 16 bit coordinates of the point to add
;
; ***************************************************************************************
state_zero

    lda newy                            ;
    clc                                 ;
    adc centrey                         ;
    sta tempY1                          ;
    and #7                              ;
    sta tempY2                          ;
    lda tempY1                          ;
    lsr                                 ;
    lsr                                 ;
    lsr                                 ;
    ora #$60                            ;
    sta screenAddrHigh,x                ;
    sta screen_high                     ;

    lda newx                            ;
    clc                                 ;
    adc centrex                         ;
    sta tempX                           ;
    and #%11111000                      ; offset in bytes from the start of the row
    clc
    adc tempY2                          ;
    sta screenAddrLow,x                 ;
    sta screen_low                      ;


    lda tempX                           ;
    and #%00000111                      ; set mask,x based on horizontal position AND 7
    tay                                 ;
    lda bitset,y                        ;
    sta mask,x                          ;

    ldy #0                              ;
    lda (screen_low),y                  ;
    eor mask,x                          ; write pixel
    sta (screen_low),y                  ;

    lda #1                              ;
    sta state,x                         ; state[quadrant] = 1;
    rts                                 ;

; ***************************************************************************************
;
; Handle state one
;
; On Entry:
;   X = quadrant
;   dir = direction
;   newx, newy are the 16 bit coordinates of the point to add
;
; ***************************************************************************************
state_one
    lda screenAddrLow,x                 ;
    sta screen_low                      ;
    lda screenAddrHigh,x                ;
    sta screen_high                     ; copy current address from main memory into zp cache

    ; Test dx
    ldy dir                             ;
    lda dx,y                            ;
    bmi move_left                       ;
    beq test_dy                         ;

move_right
    lsr mask,x                          ;
    bcc test_dy                         ;
    lda #128                            ;
    sta mask,x                          ;
    lda screen_low                      ;
    clc                                 ;
    adc #8                              ;
    sta screen_low                      ;

    ; Test dy
test_dy
    lda dy,y                            ;
    bmi move_up                         ;
    beq write_pixel                     ;
move_down
    inc screen_low                      ;
    lda screen_low                      ;
    and #%00000111                      ;
    bne +                               ; if not on row boundary, skip
    inc screen_high                     ; increment high byte on row boundary
    lda screen_low                      ;
    sec                                 ;
    sbc #8                              ;
    sta screen_low                      ;
+

write_pixel
    ldy #0                              ;
    lda (screen_low),y                  ;
    eor mask,x                          ; write pixel
    sta (screen_low),y                  ;

    lda screen_low                      ;
    sta screenAddrLow,x                 ;
    lda screen_high                     ; restore current address back into main memory from zp cache
    sta screenAddrHigh,x                ;
    rts                                 ;

move_left
    asl mask,x                          ;
    bcc test_dy                         ;
    lda #1                              ;
    sta mask,x                          ;
    lda screen_low                      ;
    sec                                 ;
    sbc #8                              ;
    sta screen_low                      ;
    jmp test_dy                         ;

move_up
    lda screen_low                      ;
    and #%00000111                      ;
    bne +                               ; if not on row boundary, skip
    lda screen_low                      ;
    clc                                 ;
    adc #7                              ;
    sta screen_low                      ;
    dec screen_high                     ;
    jmp write_pixel                     ;
+
    dec screen_low                      ;
    jmp write_pixel                     ;

; ***************************************************************************************
state
    !byte 0,0,0,0
screenAddrLow
    !byte 0,0,0,0
screenAddrHigh
    !byte 0,0,0,0
mask
    !byte 0,0,0,0

bitset
    !byte %10000000
    !byte %01000000
    !byte %00100000
    !byte %00010000
    !byte %00001000
    !byte %00000100
    !byte %00000010
    !byte %00000001

; ***************************************************************************************
variables_start

; inputs
centrex
    !word 128
;    !word 0
centrey
    !word 128
;    !word 0
a
    !word 58
b
    !word 100
zero
    !word 0         ; padding (always zero), used to make multiply32 work on b
s
    !le32 -20       ; note: 32 bit


; workspace variables
x1
    !word 0
x2
    !word 0
ox1
    !word 0
ox2
    !word 0
y
    !word 0
aa
    !le32 0
bb
    !le32 0
bb2
    !le32 0
bd
    !le32 0
dd
    !le32 0
d1
    !le32 0
t1
    !le32 0
t2
    !le32 0
tt1
    !le32 0
tt2
    !le32 0
temp
    !le32 0
yyaa
    !le32 0
yyaa_diff
    !le32 0
aabb
    !le32 0
x1b
    !le32 0
x2b
    !le32 0
st1
    !le32 0
st2
    !le32 0
ss
    !le32 0
sb
    !le32 0
bt1
    !le32 0
bt2
    !le32 0

x
    !word 0
increment
    !word 0
increment2
    !word 0
pixelx
newx
    !word 0
pixely
newy
    !word 0


; ***************************************************************************************
; static data
; ***************************************************************************************
dx
    !byte -1, 0, 1, -1, 0, 1, -1, 0, 1
dy
    !byte -1,-1,-1,0,0,0,1,1,1

set_mode
    ldx #0                                  ;
-
    lda set_mode_data,x                     ;
    jsr OSWRCH                              ;
    inx                                     ;
    cpx #set_mode_data_end - set_mode_data  ;
    bne -                                   ;
    rts                                     ;

set_mode_data
    !byte 22, 4             ; Switch to screen mode 4

    !byte 23, 0, 6, 32      ; Set 6845 register R6 = 32
    !byte 0, 0, 0           ;
    !byte 0, 0, 0           ; This is the "vertical displayed" register, and sets
                            ; the number of displayed character rows to 32.

    !byte 23, 0, 12, $0C    ; Set 6845 register R12 = $0C and R13 = $00
    !byte 0, 0, 0           ;
    !byte 0, 0, 0           ; This sets 6845 registers (R12 R13) = $0C00 to point
    !byte 23, 0, 13, $00    ; to the start of screen memory in terms of character
    !byte 0, 0, 0           ; rows. There are 8 pixel lines in each character row,
    !byte 0, 0, 0           ; so to get the actual address of the start of screen
                            ; memory, we multiply by 8:
                            ;
                            ;   $0C00 * 8 = $6000
                            ;
                            ; So this sets the start of screen memory to $6000

    !byte 23, 0, 1, 32      ; Set 6845 register R1 = 32
    !byte 0, 0, 0           ;
    !byte 0, 0, 0           ; This is the "horizontal displayed" register, which
                            ; defines the number of character blocks per horizontal
                            ; character row. For comparison, this value is 40 for
                            ; modes 4 and 5, but our custom screen is not as wide at
                            ; only 32 character blocks across

    !byte 23, 0, 2, 45      ; Set 6845 register R2 = 45
    !byte 0, 0, 0           ;
    !byte 0, 0, 0           ; This is the "horizontal sync position" register, which
                            ; defines the position of the horizontal sync pulse on
                            ; the horizontal line in terms of character widths from
                            ; the left-hand side of the screen. For comparison this
                            ; is 49 for modes 4 and 5, but needs to be adjusted for
                            ; our custom screen's width

    !byte 23, 0, 10, 32     ; Set 6845 register R10 = 32
    !byte 0, 0, 0           ;
    !byte 0, 0, 0           ; This is the "cursor start" register, so this sets the
                            ; cursor start line at 0, effectively disabling the
                            ; cursor

    !byte 31,0,7            ; move the text cursor home
set_mode_data_end

timer_block
    !byte 0,0,0,0,0         ; TIME value to set

reset_timer
    lda #2                  ;
    ldx #<timer_block       ;
    ldy #>timer_block       ;
    jmp OSWORD              ; set TIME
